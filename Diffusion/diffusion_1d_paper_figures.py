# -*- coding: utf-8 -*-
"""
Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/mannixp/PDF_Equation/blob/main/Diffusion/Diffusion_1D_Stochastic_BCS.ipynb

This notebook applies the forward Kolmogorov equation derived in *Craske J. et al. 2024* to the case of 1D scalar diffusion with boundary conditions prescribed by an Ornstein-Ulhenbeck process. 
The diffusion equation is solved using finite-differences, while the relevant terms in the forward Kolmogorov equation are estimated using histograms.

"""

from   scipy import sparse
import numpy as np
import scipy.stats as ss
import matplotlib.pyplot as plt
plt.rcParams.update({
    "text.usetex": True,
    "font.family": "sans-serif",
    "font.sans-serif": "Helvetica",
    'text.latex.preamble': r'\usepackage{amsfonts}'
})

# Solvers
def OU(Y_t,W_t,dt, μ_z,a,σ):
  
  """
  Ornstein-Ulhenbeck process
  """

  dW_t = np.sqrt(dt) * W_t

  # Euler Maruyama
  return  Y_t + a*(μ_z - Y_t)*dt + σ * dW_t

def Derivatives(N,dx):

  def Grad(N):
    Akp1 =  np.ones(N-1)
    Akm1 = -np.ones(N-1)
    return sparse.diags( [Akm1,Akp1], [-1,1] )/2

  def Laplacian(N, bcs = 'Dirichlet'):
    Akp1 = np.ones(N-1)
    Ak0  = -2*np.ones(N)
    Akm1 = np.ones(N-1)

    if bcs == 'Neumann':
        Akp1[0 ] = 2.0; # Use f_1     = f_-1    @ f_0
        Akm1[-1] = 2.0; # Use f_{N+1} = f_{N-1} @ f_N
    elif bcs == 'Dirichlet':
        Akp1[0]  = 0.
        Ak0[0]   = 0.; Ak0[-1] =0.
        Akm1[-1] = 0.

    return sparse.diags( [Akm1,Ak0,Akp1], [-1,0,1] )

  D = Grad(N)/dx
  L = Laplacian(N)/dx**2

  return D, L

def Solve(Nt=10**4,T=10,Nz=64,a=5,σ=1,W=None):

  # Domain
  z, Δz = np.linspace(0,1,Nz,retstep=True)
  t, Δt = np.linspace(0,T,Nt,retstep=True)

  # Derivatives
  D, L = Derivatives(Nz,Δz)
  I = sparse.eye(L.shape[0],format="csr")
  A = sparse.csr_matrix(I/Δt - L/2)
  B = sparse.csr_matrix(I/Δt + L/2)

  # Noise
  if W is None:
    W = ss.norm.rvs(loc=0, scale=1, size=(Nt,2))

  # Initial conditions
  Y = np.zeros((Nt,Nz))
  Yz = np.zeros((Nt,Nz))
    
  # Solve
  for n,t_i in enumerate(t[:-1]):

    # Interior according to heat diffusion
    Y[n+1,:]  = sparse.linalg.spsolve(A,B.dot(Y[n,:]))

    # BCs according to OU process
    Y[n+1, 0] = OU(Y_t=Y[n, 0], W_t=W[n,0], dt=Δt, μ_z=0, a=a, σ=σ)
    Y[n+1,-1] = OU(Y_t=Y[n,-1], W_t=W[n,1], dt=Δt, μ_z=0, a=a, σ=σ)

    # Grab the gradient
    Yz[n+1,:] = D.dot(Y[n+1,:])

  return t,z,Y,Yz

def density(Y_data,Range,N_bins):

  f,y = np.histogram(Y_data[...].flatten(),range=Range,bins=N_bins,density=True); 
  y   = 0.5*(y[1:] + y[:-1]);

  return f,y

def diffusion(dY2_data,Y_data,Range,N_bins):

  # Expectation
  # Let Φ = |∇Y|^2 and φ its dummy variable

  Y   = Y_data[...].flatten()
  dY2 = dY2_data[...].flatten()

  f_YΦ,y,φ = np.histogram2d(Y,dY2,range = (Range,(min(dY2),max(dY2))),bins=N_bins,density=True)
  φ = .5*(φ[1:]+φ[:-1]); dφ = φ[1] - φ[0];
  #y = .5*(y[1:]+y[:-1]); dy = y[1] - y[0];
  f_Y =  np.sum(  f_YΦ,axis=1)*dφ;      # f_Y(y)
  E   = (np.sum(φ*f_YΦ,axis=1)*dφ)/f_Y; # E{Φ|Y} = int_φ f_Φ|Y(φ|y)*φ dφ

  return -E

def Expectation(Y,dY,y,N_bins):

    f_YΦ,_,φ = np.histogram2d(Y,dY,range = ((min(y),max(y)),(min(dY),max(dY))),bins=N_bins,density=True) # n (-3)
    φ   = .5*(φ[1:]+φ[:-1]);
    dφ  = φ[1] - φ[0];
    E   = np.sum(φ*f_YΦ,axis=1)*dφ # E{Φ|Y=y}*f(y) = int_φ f_ΦY(φ,y)*φ dφ where φ = ∇Y_t

    return E

def drift(f,y, Y0,Y1,Yz0,Yz1,N_bins):

  nz_minus = -1 # at z=0
  nz_plus  =  1 # at z=1
  
  Y_t   = np.hstack( ( Y1[...].flatten(),   Y0[...].flatten())  )
  nDY_t = np.hstack( (nz_plus*Yz1[...].flatten(), nz_minus*Yz0[...].flatten())  )
  return 2*Expectation(Y_t,nDY_t,y,N_bins)/f


def Plot_space_time():
   
  t_vec,z_vec,Y_vec,Yz_vec = Solve()

  from matplotlib import ticker
  fig = plt.figure(figsize=(12,5),layout='constrained')
  plt.contourf(t_vec,z_vec,Y_vec.T,levels=50,cmap='RdBu')
  plt.contourf(t_vec,z_vec,Y_vec.T,levels=50,cmap='RdBu')
  cbar = plt.colorbar()
  cbar.ax.tick_params(labelsize=30) 
  tick_locator = ticker.MaxNLocator(nbins=3)
  cbar.locator = tick_locator
  cbar.update_ticks()

  plt.xlabel(r'$t$',fontsize=30)
  plt.ylabel(r'$X$',fontsize=30)
  plt.tick_params(axis='both', labelsize=30)
  plt.savefig('Diffusion_1D_Space_Time.png',dpi=200)
  plt.show()

  return None

def Generate_Ensemble(N=10**4,T=10,Paths=250):
  
  times,z,_,_=Solve(N,T)
  z_data = z[1:-1]

  pad = 50
  stp = (len(times)-pad,Paths)
  Y0_Data = np.zeros(stp)
  Y1_Data = np.zeros(stp)
  Y0zData = np.zeros(stp)
  Y1zData = np.zeros(stp)

  stzp = (len(times)-pad,len(z_data),Paths)
  Y_data   = np.zeros(stzp)
  dY2_data = np.zeros(stzp)

  W  = ss.norm.rvs(loc=0, scale=1, size=(N,2,Paths))

  for n in range(Paths):

    _,_,Y,Yz=Solve(N,T)
    Y_n,Yz_n = Y[:,1:-1],Yz[:,1:-1]

    # z-integrated
    Y_data[:,:,n]  =   Y_n[pad:,:] # time,z_data
    dY2_data[:,:,n]=  Yz_n[pad:,:]**2

    # Boundaries
    Y0_Data[:,n] = Y_n[pad:, 0] # time,z=0
    Y1_Data[:,n] = Y_n[pad:,-1]
    Y0zData[:,n] = Yz_n[pad:, 0]
    Y1zData[:,n] = Yz_n[pad:,-1]

    if n%(Paths//5) == 0:
      print('Path = %d'%n,'\n')

  return {'Y_data':Y_data,'dY2_data':dY2_data, 
          'Y0_Data':Y0_Data,'Y1_Data':Y1_Data,
          'Y0zData':Y0zData,'Y1zData':Y1zData}

def Plot_joint_density(Y0_Data,Y1_Data,Y0zData,Y1zData):

  nz_minus = -1 # at z=0
  nz_plus  =  1 # at z=1


  Y_DATA = np.concatenate((Y0_Data[...].flatten(),Y1_Data[...].flatten()))
  dY_DATA= np.concatenate((nz_minus*Y0zData[...].flatten(),nz_plus*Y1zData[...].flatten()))

  fig = plt.figure(figsize=(4,5),layout='constrained')

  plt.hist2d(x=Y0_Data[...].flatten(), y=nz_minus*Y0zData[...].flatten(),range = ((-1,1),(-5,5)),bins = 30, cmap='binary')
  plt.xlabel(r'$y$',fontsize=30)
  plt.ylabel(r'$n \cdot \nabla y$',fontsize=30)
  plt.tick_params(axis='both', labelsize=30)
  plt.savefig('Diffusion_1D_Joint_Density.png',dpi=200)
  plt.show()

  return None;

def Plot_Terms(Y_data,dY2_data, Y0_Data,Y1_Data,Y0zData,Y1zData,N_bins=1024):
  

  #Range = (   min(Y_data[...].flatten()),max(Y_data[...].flatten())  );
  Range = (-1,1)
  # Estimate the terms
  f,y = density(Y_data,Range,N_bins)
  D1  = drift(f,y, Y0_Data,Y1_Data,Y0zData,Y1zData, N_bins)
  D2  = diffusion(dY2_data,Y_data,Range,N_bins)

  # Derivative
  N = len(y)
  D = np.zeros((N,N))
  for i in range(N):
    if i < N - 1:
      D[i,i+1] = 1
    if i > 0:
      D[i,i-1] =-1
  D*=.5/(y[1]-y[0])

  fig, axs = plt.subplots(2, 2, layout='constrained',figsize=(12,6),sharex=True)

  axs[0,0].plot(y,D1,'k', linewidth=2,label=r'$\mathbf{D}^{(1)}(y)$')
  axs[0,1].plot(y,D2,'k', linewidth=2,label=r'$\mathbf{D}^{(2)}(y)$')

  from scipy.ndimage import gaussian_filter1d
  LHS = gaussian_filter1d(D1*f,sigma=2)
  RHS = D@(gaussian_filter1d(D2*f,sigma=2))
  
  axs[1,0].plot(y[1:-1],RHS[1:-1],'b--', linewidth=2,label=r'$\partial_y \left( \mathbf{D}^{(2)} f_Y \right)$')
  axs[1,0].plot(y[1:-1],LHS[1:-1],'r-', linewidth=2,label=r'$\mathbf{D}^{(1)} f_Y$')
  axs[1,0].set_xlabel(r'$y$',fontsize=24)

  axs[1,1].plot(y,f,'r', linewidth=2,label=r'$f_Y(y)$')
  axs[1,1].fill_between(x=y,y1=f,color= "r",alpha= 0.2)
  axs[1,1].set_ylim([0,1.1*max(f)])
  axs[1,1].set_xlabel(r'$y$',fontsize=24)


  axs[0,0].annotate(r'(a)', xy=(0.05,0.85), xycoords='axes fraction',fontsize=24)
  axs[0,1].annotate(r'(b)', xy=(0.05,0.85), xycoords='axes fraction',fontsize=24)
  axs[1,0].annotate(r'(c)', xy=(0.05,0.85), xycoords='axes fraction',fontsize=24)
  axs[1,1].annotate(r'(d)', xy=(0.05,0.85), xycoords='axes fraction',fontsize=24)

  for ax in [axs[0,0],axs[1,0],axs[0,1],axs[1,1]]:
    ax.set_xlim([min(y),max(y)])
    ax.legend(loc=8,fontsize=20)
    ax.tick_params(axis='both', labelsize=20)

  axs[1,0].legend(loc=4,fontsize=20)

  plt.savefig('Diffusion_1D_Coefficients.png',dpi=200)
  plt.show()

  return None;


if __name__ == "__main__":

  # %%
  #%matplotlib inline

  # %%
  # plot the space time diffusion process
  Plot_space_time()

  # %%
  # Generate Ensemble of data
  try:
    DAT = np.load('DATA.npy',allow_pickle='TRUE').item()
    print('Loading data ... \n')
  except:    
    print('Generating data ... \n')
    DAT = Generate_Ensemble()
    np.save('DATA.npy',DAT) 
  
  # %%
  # plot the joint densities
  Plot_joint_density(DAT['Y0_Data'],DAT['Y1_Data'],DAT['Y0zData'],DAT['Y1zData'])

  # %%
  # plot the terms and coefficients
  Plot_Terms(DAT['Y_data'],DAT['dY2_data'], 
             DAT['Y0_Data'],DAT['Y1_Data'],DAT['Y0zData'],DAT['Y1zData'],N_bins=1024)

# %%
