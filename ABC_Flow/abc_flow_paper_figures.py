# -*- coding: utf-8 -*-
"""
Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/mannixp/PDF_Equation/blob/main/ABC_Flow.ipynb

This notebook applies the forward Kolmogorov equation derived in *Craske J. et al. 2024* to the case of a scalar concentration evolving subject to an advection diffusion equation in a triply peridioc domain. The advection diffusion equation is solved using the open source pseudo-spectral code [Dedalus](https://dedalus-project.org/) (*Burns K.J. et. al. 2020*), while the relevant terms in the forward Kolmogorov equation are estimated using histograms.
"""

import numpy as np
import dedalus.public as d3
import logging
import h5py
logger = logging.getLogger(__name__)

def solve(stop_sim_time,Nx=32):
    
    # Parameters
    κ = 0.1;  # Equivalent to Peclet number
    timestep = 5e-03

    # Domain
    coords = d3.CartesianCoordinates('X_1','X_2','X_3')
    dist   = d3.Distributor(coords, dtype=np.float64)
    X1_basis = d3.RealFourier(coords['X_1'], size=Nx, bounds=(-np.pi, np.pi), dealias=3/2)
    X2_basis = d3.RealFourier(coords['X_2'], size=Nx, bounds=(-np.pi, np.pi), dealias=3/2)
    X3_basis = d3.RealFourier(coords['X_3'], size=Nx, bounds=(-np.pi, np.pi), dealias=3/2)

    # Fields
    Y = dist.Field(name='Y', bases=(X1_basis,X2_basis,X3_basis))
    U = dist.VectorField(coords, name='U', bases=(X1_basis,X2_basis,X3_basis))
    X_1,X_2,X_3 = dist.local_grids(X1_basis,X2_basis,X3_basis)

    # ABC flow
    U['g'][0] = np.sin(X_3) + np.cos(X_2);
    U['g'][1] = np.sin(X_1) + np.cos(X_3);
    U['g'][2] = np.sin(X_2) + np.cos(X_1);

    # Initial condition
    Y['g']    = np.tanh(10*(X_1 + X_2 + X_3))

    # Problem
    grad_Y  = d3.grad(Y)
    problem = d3.IVP([Y], namespace=locals())
    problem.add_equation("dt(Y) - κ*div(grad_Y) = -U@grad(Y)") #

    # Solver
    solver = problem.build_solver(d3.RK222)
    solver.stop_sim_time = stop_sim_time

    # Main loop
    try:
        logger.info('Starting main loop')
        while solver.proceed:
            
            solver.step(timestep)

            # Capture the last 5 snapshots
            if  solver.iteration == int(stop_sim_time/timestep) - 5:
                snapshots = solver.evaluator.add_file_handler('snapshots', iter=1)
                snapshots.add_task(Y,      layout='g',name='Y'     ,scales=3/2)
                snapshots.add_task(grad_Y, layout='g',name='grad_Y',scales=3/2)
    except:
        logger.error('Exception raised, triggering end of main loop.')
        raise
    finally:
        solver.log_stats()

    return None;

def Data(N_bins=256):
    
    # Data loading
    file   = h5py.File('./snapshots/snapshots_s1.h5', mode='r')
    times  = file['tasks/Y'].dims[0][0][:]
    X1_data = file['tasks/Y'].dims[1][0][:]
    X2_data = file['tasks/Y'].dims[2][0][:]
    X3_data = file['tasks/Y'].dims[3][0][:]

    Y_data   = file['tasks/Y'][:,...]
    dY2_data = np.sum(file['tasks/grad_Y'][...]**2,axis=1)

    # PDF f_Y
    f_np2,y = np.histogram(Y_data[-1,...].flatten(),bins=N_bins,density=True); # n + 2 (-1)
    f_np1,y = np.histogram(Y_data[-2,...].flatten(),bins=N_bins,density=True); # n + 1 (-2)

    f_nm1,y = np.histogram(Y_data[-4,...].flatten(),bins=N_bins,density=True); # n - 1 (-4)
    f_nm2,y = np.histogram(Y_data[-5,...].flatten(),bins=N_bins,density=True); # n - 2 (-5)

    y       = 0.5*(y[1:] + y[:-1]); dy = y[1] - y[0];

    # Time derivate df_s/dt
    dt   = times[-1] - times[-2];
    dfdt = (-1./12.)*f_np2 + (2./3.)*f_np1 - (2./3.)*f_nm1 + (1./12.)*f_nm2;
    dfdt /=dt;

    # Expectation
    f_YΦ,y,φ = np.histogram2d(Y_data[-3,...].flatten(), dY2_data[-3,...].flatten(),bins=N_bins,density=True) # n (-3)
    φ = .5*(φ[1:]+φ[:-1]); dφ = φ[1] - φ[0];
    y = 0.5*(y[1:] + y[:-1]); dy = y[1] - y[0];

    f_Y =  np.sum(  f_YΦ,axis=1)*dφ     # f_Y(y)
    E   = (np.sum(φ*f_YΦ,axis=1)*dφ)/f_Y; # E{Φ|Y} = int_φ f_Φ|Y(φ|y)*φ dφ
    
    return X1_data,X2_data,Y_data,y,f_Y,E

def Plot(x_data,y_data,Y_data,y,f,E,stop_sim_time):

    # Commented out IPython magic to ensure Python compatibility.
    #import matplotlib as mpl
    #mpl.rcParams['xtick.major.size'] = 16
    #mpl.rcParams['ytick.major.size'] = 16

    import matplotlib.pyplot as plt
    plt.rcParams.update({
        "text.usetex": True,
        "font.family": "sans-serif",
        "font.sans-serif": "Helvetica",
        'text.latex.preamble': r'\usepackage{amsfonts}'
    })

    fig, axs = plt.subplots(2,1,figsize=(4,8),layout='constrained')

    axs[0].pcolormesh(x_data,y_data,Y_data[-1,:,:,0],cmap='RdBu',norm='linear')
    axs[0].set_ylabel(r'$X_2$',fontsize=24)
    axs[0].set_xlabel(r'$X_1$',fontsize=24)
    axs[0].set_xticks([-2,0,2])
    axs[0].set_yticks([-2,0,2])

    axs[1].plot(y,f,'r', linewidth=2)
    axs[1].fill_between(x=y,y1=f,color= "r",alpha= 0.2)
    axs[1].plot(y,E,'b', linewidth=2)
    
    axs[1].set_xlim([-1.05,1.05])
    lim = max(np.max(E),np.max(f))
    axs[1].set_ylim([0.,1.1*lim])
    axs[1].set_xlabel(r'$y$'  ,fontsize=24)

    for n,ax in enumerate(fig.axes):
        ax.set_box_aspect(aspect=1)
        ax.tick_params(axis='x', labelsize=20)
        ax.tick_params(axis='y', labelsize=20)

    plt.savefig('ABC_Flow_t%2.2f.png'%stop_sim_time,dpi=200)

    return None;

if __name__ == "__main__":
    
    for t in [0.5,1.0,2.0,4.0]:
        solve(stop_sim_time=t,Nx=48)
        x_data,y_data,Y_data,y,f,E = Data(N_bins=128)
        Plot(x_data,y_data,Y_data,y,f,E,stop_sim_time=t)
