# -*- coding: utf-8 -*-
"""
Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/mannixp/PDF_Equation/blob/main/ABC_Flow.ipynb

This notebook applies the forward Kolmogorov equation derived in *Craske J. et al. 2024* to the case of a scalar concentration evolving subject to an advection diffusion equation in a triply peridioc domain. 
The advection diffusion equation is solved using a Fourier psuedo-spectral method, while the relevant terms in the forward Kolmogorov equation are estimated using histograms.
"""

import numpy as np
from scipy import sparse
import h5py

def solve(T,Nx=32,Δt=1e-03):
    
    # Parameters
    A,B,C = 1,1,1

    # Domain
    x, Δx = np.linspace(-np.pi,np.pi,Nx,retstep=True)
    t = np.arange(0,T,Δt); Nt = len(t)
    
    # Derivatives
    ik = 1j*np.zeros(Nx)
    ik[0:Nx//2+1] = 1j*np.arange(0,Nx//2+1)
    ik[Nx//2+1:]  = 1j*np.arange(-Nx//2+1,0,1)

    I  = sparse.eye(Nx)
    D2 = sparse.diags([ik**2],[0])
    
    ik[Nx//2] = 0.
    D  = sparse.diags([ik   ],[0])
    
    D_1 = sparse.kron( sparse.kron(D,I), I)
    D_2 = sparse.kron( sparse.kron(I,D), I)
    D_3 = sparse.kron( sparse.kron(I,I), D)
    
    L = sparse.kron(sparse.kron(D2,I),I) + sparse.kron(sparse.kron(I,D2),I) + sparse.kron( sparse.kron(I,I), D2)
   
    II= sparse.eye(Nx**3,format="csr")
    LHS = sparse.csr_matrix(II/Δt - L/2)
    RHS = sparse.csr_matrix(II/Δt + L/2)

    # ABC flow
    X_1,X_2,X_3,_ = np.meshgrid(x,x,x,'ij')
    X_1,X_2,X_3 = X_1[...,0],X_2[...,0],X_3[...,0]

    U_1 = A*np.sin(X_3) + C*np.cos(X_2)
    U_2 = B*np.sin(X_1) + A*np.cos(X_3)
    U_3 = C*np.sin(X_2) + B*np.cos(X_1)

    # Initial conditions
    Y_data = np.zeros((Nt,Nx,Nx,Nx))
    DY2_data = np.zeros((Nt,Nx,Nx,Nx))

    Y_0 = np.tanh(1*(X_1 + X_2 + X_3))
    Y = np.fft.fftn(Y_0).flatten()
    
    # Solve
    for n,t_i in enumerate(t):

        # Compute ∇Y on k-space
        DY_1 = (D_1@Y).reshape((Nx,Nx,Nx))
        DY_2 = (D_2@Y).reshape((Nx,Nx,Nx))
        DY_3 = (D_3@Y).reshape((Nx,Nx,Nx))

        # Multiply U.∇Y in g-space
        DY_1 = np.fft.ifftn(DY_1).real
        DY_2 = np.fft.ifftn(DY_2).real
        DY_3 = np.fft.ifftn(DY_3).real

        u_grad_Y = U_1*DY_1 + U_2*DY_2 + U_3*DY_3

        Y_data[n,...]   = np.fft.ifftn( Y.reshape((Nx,Nx,Nx)) ).real
        DY2_data[n,...] = DY_1**2 + DY_2**2 + DY_3**2

        # FFTn U.∇Y into k-space
        F = np.fft.fftn( u_grad_Y ).flatten()

        # Interior according to heat diffusion
        Y = sparse.linalg.spsolve(LHS,RHS.dot(Y) - F )

        if n%100 == 0:
            print('mean = ',np.mean(Y_data[n,...]))

    # Save data
    f = h5py.File('snapshots.h5', mode='w')
    tasks = f.create_group("tasks")
    tasks['t'] = t
    tasks['x'] = x
    tasks['Y'] = Y_data
    tasks['DY2'] = DY2_data
    f.close()

    return None

def Data(N_bins=256):
    
    # Data loading
    file   = h5py.File('snapshots.h5', mode='r')
    times  = file['tasks/t'][:]
    X1_data = file['tasks/x'][:]
    X2_data = file['tasks/x'][:]
    X3_data = file['tasks/x'][:]

    Y_data   = file['tasks/Y'][:,...]
    dY2_data = file['tasks/DY2'][:,...]

    file.close()


    # PDF f_Y
    f_np2,y = np.histogram(Y_data[-1,...].flatten(),bins=N_bins,density=True); # n + 2 (-1)
    f_np1,y = np.histogram(Y_data[-2,...].flatten(),bins=N_bins,density=True); # n + 1 (-2)

    f_nm1,y = np.histogram(Y_data[-4,...].flatten(),bins=N_bins,density=True); # n - 1 (-4)
    f_nm2,y = np.histogram(Y_data[-5,...].flatten(),bins=N_bins,density=True); # n - 2 (-5)

    y       = 0.5*(y[1:] + y[:-1]); dy = y[1] - y[0];

    # Time derivate df_s/dt
    dt   = times[-1] - times[-2];
    dfdt = (-1./12.)*f_np2 + (2./3.)*f_np1 - (2./3.)*f_nm1 + (1./12.)*f_nm2;
    dfdt /=dt;

    # Expectation
    f_YΦ,y,φ = np.histogram2d(Y_data[-3,...].flatten(), dY2_data[-3,...].flatten(),bins=N_bins,density=True) # n (-3)
    φ = .5*(φ[1:]+φ[:-1]); dφ = φ[1] - φ[0];
    y = 0.5*(y[1:] + y[:-1]); dy = y[1] - y[0];

    f_Y =  np.sum(  f_YΦ,axis=1)*dφ     # f_Y(y)
    E   = (np.sum(φ*f_YΦ,axis=1)*dφ)/f_Y; # E{Φ|Y} = int_φ f_Φ|Y(φ|y)*φ dφ
    
    return X1_data,X2_data,Y_data,y,f_Y,E

def Plot(x_data,y_data,Y_data,y,f,E,stop_sim_time):

    # Commented out IPython magic to ensure Python compatibility.
    #import matplotlib as mpl
    #mpl.rcParams['xtick.major.size'] = 16
    #mpl.rcParams['ytick.major.size'] = 16

    import matplotlib.pyplot as plt
    # plt.rcParams.update({
    #     "text.usetex": True,
    #     "font.family": "sans-serif",
    #     "font.sans-serif": "Helvetica",
    #     'text.latex.preamble': r'\usepackage{amsfonts}'
    # })

    fig, axs = plt.subplots(2,1,figsize=(4,8),layout='constrained')

    axs[0].pcolormesh(x_data,y_data,Y_data[-1,:,:,0],cmap='RdBu',norm='linear')
    axs[0].set_ylabel(r'$X_2$',fontsize=24)
    axs[0].set_xlabel(r'$X_1$',fontsize=24)
    axs[0].set_xticks([-2,0,2])
    axs[0].set_yticks([-2,0,2])

    axs[1].plot(y,f,'r', linewidth=2)
    axs[1].fill_between(x=y,y1=f,color= "r",alpha= 0.2)
    axs[1].plot(y,E,'b', linewidth=2)
    
    axs[1].set_xlim([-1.05,1.05])
    # lim = max(np.max(E),np.max(f))
    # axs[1].set_ylim([0.,1.1*lim])
    axs[1].set_xlabel(r'$y$'  ,fontsize=24)

    for n,ax in enumerate(fig.axes):
        ax.set_box_aspect(aspect=1)
        ax.tick_params(axis='x', labelsize=20)
        ax.tick_params(axis='y', labelsize=20)

    plt.show()
    plt.savefig('ABC_Flow_t%2.2f.png'%stop_sim_time,dpi=200)

    return None;

if __name__ == "__main__":
    
    # %%
    %matplotlib inline

    # %%
    for t in [0.05,0.5,1.0]:
        print('time t=%3.3f \n'%t)
        solve(T=t,Nx=24,Δt=1e-04)
        x_data,y_data,Y_data,y,f,E = Data(N_bins=128)
        Plot(x_data,y_data,Y_data,y,f,E,stop_sim_time=t)
    
    # %%
