# -*- coding: utf-8 -*-
"""
Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/mannixp/PDF_Equation/blob/main/ABC_Flow.ipynb

This notebook applies the forward Kolmogorov equation derived in *Craske J. et al. 2024* to the case of a scalar concentration evolving subject to an advection diffusion equation in a triply peridioc domain. 
The advection diffusion equation is solved using a Fourier psuedo-spectral method, while the relevant terms in the forward Kolmogorov equation are estimated using histograms.
"""

from scipy import sparse
import numpy as np
import h5py, copy
import matplotlib.pyplot as plt


def wavenumbers(N):
    """Return wavenumbers for the periodic domain."""
    ik = 1j*np.zeros(N)
    ik[0:N//2+1] = 1j*np.arange(0,N//2+1)
    ik[N//2+1:]  = 1j*np.arange(-N//2+1,0,1)
    return ik

def domain(N,test=False):
    """Generate a grid for x."""
    if test == True:
        h = 2*np.pi/N
        x = h*np.arange(1,N+1,1)
    else:
        x, h = np.linspace(-np.pi,np.pi,N,retstep=True)
    return x,h

def derivative(f,axis=0,deriv=1):
    """Compute any 1st or 2nd derivative of a 1,2 or 3D field."""

    # Determine the dimension (dim) and size (N).
    dim = len(f.shape)
    N   = f.shape[0]

    # Create the 1st and 2nd derivative operators
    ik = wavenumbers(N)
    if deriv == 1:
        ik[N//2] = 0
        D = sparse.diags([ik],[0])   
    elif deriv == 2:
        D = sparse.diags([ik**2],[0])
    else:
        return f
      
    I = sparse.eye(N)
    F = f.flatten()

    # Compute the derivative
    if dim == 1:
        return D@F
    
    elif dim == 2:

        if axis == 0:
            Di = sparse.kron(D,I)
        elif axis == 1:    
            Di = sparse.kron(I,D)
        
        df = Di@F 
        return df.reshape((N,N))
    
    elif dim == 3:

        if axis == 0:
            Di = sparse.kron(sparse.kron(D,I),I)
        elif axis == 1:    
            Di = sparse.kron(sparse.kron(I,D),I)
        elif axis == 2:    
            Di = sparse.kron(sparse.kron(I,I),D)

        df = Di@F 
        return df.reshape((N,N,N))
    
    return None

def tests(N=32):
    """Test the derivative function on analytic functions."""
    
    x, h = domain(N,test=True)
    y = copy.deepcopy(x)
    z = copy.deepcopy(x)

    f_x = np.cos(x)
    df_x = -np.sin(x)
    ddf_x = -np.cos(x)

    f_y = np.sin(3*y)
    df_y = 3*np.cos(3*y)
    ddf_y = -9*np.sin(3*y)

    f_z = np.sin(4*z)
    df_z = 4*np.cos(4*z)
    ddf_z = -16*np.sin(4*z)
    
    def test_derivative_1D():

        f_hat = np.fft.fft(f_x)
        
        df_x_hat = derivative(f_hat,axis=0,deriv=1)
        df_x_num = np.fft.ifft(df_x_hat).real
        error_x = np.sum((df_x - df_x_num)**2) * h
        print('Error 1D 1st =',error_x)

        ddf_x_hat = derivative(f_hat,axis=0,deriv=2)
        ddf_x_num = np.fft.ifft(ddf_x_hat).real
        error_xx = np.sum((ddf_x - ddf_x_num)**2) * h
        print('Error 1D 2nd =',error_xx)

        assert (error_x < 1e-15) and (error_xx < 1e-15)

    def test_derivative_2D():

        F = np.outer(f_x,f_y)
        
        F_x = np.outer(df_x,f_y)
        F_y = np.outer(f_x,df_y)
        F_xx = np.outer(ddf_x,f_y)
        F_yy = np.outer(f_x,ddf_y)

        F_hat = np.fft.fftn(F)
        
        # check 1st derivatives
        for i,F_i in enumerate([F_x,F_y]):
            F_i_hat = derivative(F_hat,axis=i,deriv=1)
            F_i_num = np.fft.ifftn(F_i_hat).real
            error = np.sum((F_i - F_i_num)**2) * h**2
            print('Error 2D 1st in axis %d = %e'%(i,error))
            assert error < 1e-15

        # check 2nd derivatives
        for i,F_ii in enumerate([F_xx,F_yy]):
            F_ii_hat = derivative(F_hat,axis=i,deriv=2)
            F_ii_num = np.fft.ifftn(F_ii_hat).real
            error = np.sum((F_ii - F_ii_num)**2) * h**2
            print('Error 2D 2nd in axis %d = %e'%(i,error))
            assert error < 1e-15

    def test_derivative_3D():

        F = np.kron(np.kron(f_x,f_y),f_z).reshape((N,N,N))
        
        F_x =  np.kron(np.kron(df_x,f_y),f_z).reshape((N,N,N))
        F_y =  np.kron(np.kron(f_x,df_y),f_z).reshape((N,N,N))
        F_z =  np.kron(np.kron(f_x,f_y),df_z).reshape((N,N,N))
        F_xx =  np.kron(np.kron(ddf_x,f_y),f_z).reshape((N,N,N))
        F_yy =  np.kron(np.kron(f_x,ddf_y),f_z).reshape((N,N,N))
        F_zz =  np.kron(np.kron(f_x,f_y),ddf_z).reshape((N,N,N))

        F_hat = np.fft.fftn(F)
        
        # check 1st derivatives
        for i,F_i in enumerate([F_x,F_y,F_z]):
            F_i_hat = derivative(F_hat,axis=i,deriv=1)
            F_i_num = np.fft.ifftn(F_i_hat).real
            error = np.sum((F_i - F_i_num)**2) * h**3
            print('Error 3D 1st in axis %d = %e'%(i,error))
            assert error < 1e-15

        # check 2nd derivatives
        for i,F_ii in enumerate([F_xx,F_yy,F_zz]):
            F_ii_hat = derivative(F_hat,axis=i,deriv=2)
            F_ii_num = np.fft.ifftn(F_ii_hat).real
            error = np.sum((F_ii - F_ii_num)**2) * h**3
            print('Error 3D 2nd in axis %d = %e'%(i,error))
            assert error < 1e-15

    test_derivative_1D()
    print("\n")
    test_derivative_2D()
    print("\n")
    test_derivative_3D()

    return None

def solve(T,Nx=64,Δt=5e-03, A=1,B=1,C=1):
    """Solve the advection diffusion equation with an ABC flow."""

    # Parameters
    𝛼 = 1/10 # Equivalent to the Peclet number

    # Domain
    x, h = domain(Nx)
    t = np.arange(0,T,Δt)
    Nt = len(t)
    
    # Derivatives
    ik = wavenumbers(Nx)
    II = sparse.eye(Nx)
    D2 = sparse.diags([ik**2],[0])
    L = sparse.kron(sparse.kron(D2,II),II) + sparse.kron(sparse.kron(II,D2),II) + sparse.kron(sparse.kron(II,II),D2)
    L *= 𝛼
    III = sparse.eye(Nx**3,format="csr")
    LHS = sparse.csr_matrix(III/Δt - L/2)
    RHS = sparse.csr_matrix(III/Δt + L/2)

    # ABC flow
    I   = np.ones(Nx) 
    X_1 = np.kron(np.kron(x,I),I).reshape((Nx,Nx,Nx))
    X_2 = np.kron(np.kron(I,x),I).reshape((Nx,Nx,Nx))
    X_3 = np.kron(np.kron(I,I),x).reshape((Nx,Nx,Nx))

    U_1 = A*np.sin(X_3) + C*np.cos(X_2)
    U_2 = B*np.sin(X_1) + A*np.cos(X_3)
    U_3 = C*np.sin(X_2) + B*np.cos(X_1)
    U   = [U_1,U_2,U_3]

    # check divergence = 0
    div_U = 0*U_1
    for i,U_i in enumerate(U):
        U_i_hat = np.fft.fftn(U_i,axes=(i,)) 
        dU_i_hat = derivative(U_i_hat,axis=i)
        dU_i = np.fft.ifftn(dU_i_hat,axes=(i,)).real
        div_U += dU_i
    assert abs( np.sum(div_U) * h**3 ) < 1e-15
    
    # Initial conditions
    Y_data   = np.zeros((Nt,Nx,Nx,Nx))
    DY2_data = np.zeros((Nt,Nx,Nx,Nx))

    Y_0 = np.tanh(10*(X_1 + X_2 + X_3))
    Y_hat = np.fft.fftn(Y_0).flatten()
    
    # Solve
    for n,t_i in enumerate(t):

        # Compute NL terms
        Y_hat = Y_hat.reshape((Nx,Nx,Nx))
        Y_data[n,...] = np.fft.ifftn(Y_hat).real
        
        u_grad_Y = np.zeros((Nx,Nx,Nx))
        for i,U_i in enumerate(U):
            DY_hat_i  = derivative(Y_hat,axis=i,deriv=1)
            DY_i      = np.fft.ifftn(DY_hat_i).real
            u_grad_Y += U_i*DY_i
            DY2_data[n,...] += 𝛼*DY_i**2
        F_hat = np.fft.fftn(u_grad_Y).flatten()
        Y_hat = Y_hat.flatten()

        # Update
        Y_hat = sparse.linalg.spsolve(LHS,RHS.dot(Y_hat) - F_hat)

        # Check <Y> = 0 maintained
        if n%100 == 0:
            assert np.abs(Y_data[n,...].mean()) < 1e-15

    # Save data
    f = h5py.File('snapshots.h5', mode='w')
    tasks = f.create_group("tasks")
    tasks['t'] = t
    tasks['x'] = x
    tasks['Y'] = Y_data
    tasks['DY2'] = DY2_data
    f.close()

    return None

def Data(N_bins=256):
    
    # Data loading
    file   = h5py.File('snapshots.h5', mode='r')
    times  = file['tasks/t'][:]
    X1_data = file['tasks/x'][:]
    X2_data = file['tasks/x'][:]
    X3_data = file['tasks/x'][:]

    Y_data   = file['tasks/Y'][:,...]
    dY2_data = file['tasks/DY2'][:,...]

    file.close()


    # PDF f_Y
    f_np2,y = np.histogram(Y_data[-1,...].flatten(),bins=N_bins,density=True); # n + 2 (-1)
    f_np1,y = np.histogram(Y_data[-2,...].flatten(),bins=N_bins,density=True); # n + 1 (-2)

    f_nm1,y = np.histogram(Y_data[-4,...].flatten(),bins=N_bins,density=True); # n - 1 (-4)
    f_nm2,y = np.histogram(Y_data[-5,...].flatten(),bins=N_bins,density=True); # n - 2 (-5)

    y       = 0.5*(y[1:] + y[:-1]); dy = y[1] - y[0];

    # Time derivate df_s/dt
    dt   = times[-1] - times[-2];
    dfdt = (-1./12.)*f_np2 + (2./3.)*f_np1 - (2./3.)*f_nm1 + (1./12.)*f_nm2;
    dfdt /=dt;

    # Expectation
    f_YΦ,y,φ = np.histogram2d(Y_data[-3,...].flatten(), dY2_data[-3,...].flatten(),bins=N_bins,density=True) # n (-3)
    φ = .5*(φ[1:]+φ[:-1]); dφ = φ[1] - φ[0];
    y = 0.5*(y[1:] + y[:-1]); dy = y[1] - y[0];

    f_Y =  np.sum(  f_YΦ,axis=1)*dφ     # f_Y(y)
    E   = (np.sum(φ*f_YΦ,axis=1)*dφ)/f_Y; # E{Φ|Y} = int_φ f_Φ|Y(φ|y)*φ dφ
    
    return X1_data,X2_data,Y_data,y,f_Y,E

def Plot(x_data,y_data,Y_data,y,f,E,stop_sim_time):

    # Commented out IPython magic to ensure Python compatibility.
    #import matplotlib as mpl
    #mpl.rcParams['xtick.major.size'] = 16
    #mpl.rcParams['ytick.major.size'] = 16

    import matplotlib.pyplot as plt
    # plt.rcParams.update({
    #     "text.usetex": True,
    #     "font.family": "sans-serif",
    #     "font.sans-serif": "Helvetica",
    #     'text.latex.preamble': r'\usepackage{amsfonts}'
    # })

    fig, axs = plt.subplots(2,1,figsize=(4,8),layout='constrained')

    axs[0].pcolormesh(x_data,y_data,Y_data[-1,:,:,0],cmap='RdBu',norm='linear')
    axs[0].set_ylabel(r'$X_2$',fontsize=24)
    axs[0].set_xlabel(r'$X_1$',fontsize=24)
    axs[0].set_xticks([-2,0,2])
    axs[0].set_yticks([-2,0,2])

    axs[1].plot(y,f,'r', linewidth=2)
    axs[1].fill_between(x=y,y1=f,color= "r",alpha= 0.2)
    axs[1].plot(y,E,'b', linewidth=2)
    
    axs[1].set_xlim([-1.05,1.05])
    # lim = max(np.max(E),np.max(f))
    # axs[1].set_ylim([0.,1.1*lim])
    axs[1].set_xlabel(r'$y$'  ,fontsize=24)

    for n,ax in enumerate(fig.axes):
        ax.set_box_aspect(aspect=1)
        ax.tick_params(axis='x', labelsize=20)
        ax.tick_params(axis='y', labelsize=20)

    plt.show()
    plt.savefig('ABC_Flow_t%2.2f.png'%stop_sim_time,dpi=200)

    return None;

if __name__ == "__main__":
    
    # %%
    %matplotlib inline

    # %%
    tests()

    # %%
    for t in [0.5,1,2,4]:
        print('time t=%3.3f \n'%t)
        solve(T=t,Nx=64,Δt=5e-03)
        x_data,y_data,Y_data,y,f,E = Data(N_bins=128)
        Plot(x_data,y_data,Y_data,y,f,E,stop_sim_time=t)
    
    # %%
